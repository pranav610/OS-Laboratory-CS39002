#include "malware.hpp"

void getstatus(pid_t pid, statusMap& statusValues)
{   
    char statusFile[100];
    sprintf(statusFile, "/proc/%d/status", pid);
    std::ifstream fileStream;
    fileStream.open(statusFile);
    std::string line;
    while (std::getline(fileStream, line))
    {
        std::istringstream is_line(line);
        std::string key;
        if (std::getline(is_line, key, ':'))
        {
            std::string value;
            if (std::getline(is_line, value))
                statusValues[key] = value;
        }
    }
}

void returnChildren(pid_t pid, set<int>& pids)
{
    DIR *dirp = opendir("/proc");
    if (!dirp) {
        perror("opendir");
        exit(1);
    }

    struct dirent *entry;
    while ((entry = readdir(dirp)) != NULL) {
        if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, ".."))
            continue;
        if (entry->d_type != DT_DIR)
            continue;
        
        char statusFile[1000];
        sprintf(statusFile, "/proc/%s/status", entry->d_name);
        std::ifstream fileStream;
        fileStream.open(statusFile);
        std::string line;
        while (std::getline(fileStream, line))
        {
            std::istringstream is_line(line);
            std::string key;
            if (std::getline(is_line, key, ':'))
            {
                std::string value;
                if (std::getline(is_line, value))
                {
                    if(key.compare("PPid")==0 && atoi(value.c_str())==pid)
                    {
                        pids.insert(atoi(entry->d_name));
                        returnChildren(atoi(entry->d_name), pids);
                    }
                }
            }
        }
    }
    closedir(dirp);
}

int countChildren(pid_t pid)
{   
    int ret = 0;
    DIR *dirp = opendir("/proc");
    if (!dirp) {
        perror("opendir");
        exit(1);
    }

    struct dirent *entry;
    while ((entry = readdir(dirp)) != NULL) {
        if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, ".."))
            continue;
        if (entry->d_type != DT_DIR)
            continue;
        
        char statusFile[1000];
        sprintf(statusFile, "/proc/%s/status", entry->d_name);
        std::ifstream fileStream;
        fileStream.open(statusFile);
        std::string line;
        while (std::getline(fileStream, line))
        {
            std::istringstream is_line(line);
            std::string key;
            if (std::getline(is_line, key, ':'))
            {
                std::string value;
                if (std::getline(is_line, value))   
                    if(key=="PPid" && atoi(value.c_str())==pid)
                    {
                        ret++;
                        ret += countChildren(atoi(entry->d_name));
                    }
            }
        }
    }
    closedir(dirp);
    return ret;
}

int main(int argc, char *argv[])
{   
    int count = 3;
    map<string, string> statusValues[3];
    pid_t pids[3];
    pid_t pid_given;
    bool suggest = ((argc == 3) && (strcmp(argv[1], "--suggest")==0 || strcmp(argv[2], "--suggest")==0));
    

    if(strcmp(argv[1], "--suggest")!=0)
        pid_given = atoi(argv[1]);
    else
        pid_given = atoi(argv[2]);

    pids[0] = pid_given;
    getstatus(pids[0], statusValues[0]);
    pids[1] = atoi(statusValues[0]["PPid"].c_str());
    getstatus(pids[1], statusValues[1]);
    pids[2] = atoi(statusValues[1]["PPid"].c_str());
    if(pids[2] == 0)
        count--;
    else
        getstatus(pids[2], statusValues[2]);
    
    printf("Process Tree:\n");
    for(int i=0; i<3; i++)
    {   
        if(i==count)
        {
            printf("Process %d: ", i+1);
            printf("PID: %d\n, ", pids[i]);
            break;
        }
        printf("Process %d: ", i+1);
        printf("%s, \t", statusValues[i]["Name"].c_str());
        printf("PID: %d, \t", pids[i]);
        printf("State: %s, \t", statusValues[i]["State"].c_str());
        printf("Children: %d\n" , countChildren(pids[i]));
    }

    if(suggest)
    {
        printf("Suggested Trojan PID is: ");
        pid_t suggestedPid = -1;

        string guessName = statusValues[0]["Name"];
        set<int> possPids;
        possPids.insert(0);
        for(int i=0; i<count; i++)
        {   
            if(statusValues[i]["Name"] == guessName)
                possPids.insert(i);
        }
        for(int i=0; i<count; i++)
        {   
            // get first non space character from statusValues[i]["State"]
            char statechar;
            int len = statusValues[i]["State"].length();
            for(int j=0; j<len; j++)
            {
                if(statusValues[i]["State"][j] >= 'A' && statusValues[i]["State"][j] <= 'Z')
                {
                    statechar = statusValues[i]["State"][j];
                    break;
                }
            }
            if(statechar == 'S' && possPids.find(i)!=possPids.end())
                suggestedPid = pids[i];
        }
        
        if(suggestedPid == -1)
        {
            int maxChildrenInd = *possPids.begin();
            int maxChildren = 0;
            for(int i=0; i<count; i++)
            {
                if(possPids.find(i)!=possPids.end())
                {
                    int children = countChildren(pids[i]);
                    if(children > maxChildren)
                    {
                        maxChildren = children;
                        maxChildrenInd = i;
                    }
                }
            }
            suggestedPid = pids[maxChildrenInd];
        }
        printf("%d\n", suggestedPid);
        printf("Do you want to kill this process and all its children? (y/n) ");
        char c;
        scanf("%c", &c);
        if(c=='y')
        {
            set<int> children;
            returnChildren(suggestedPid, children);
            for(auto it=children.begin(); it!=children.end(); it++)
            {
                kill(*it, SIGKILL);
            }
            kill(suggestedPid, SIGKILL);
            printf("Killed.\n");
        }
        printf("Done.\n");
    }
}